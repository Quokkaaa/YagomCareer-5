## iOS 커리어 스타터 캠프

### 묵찌빠 프로젝트 저장소

# 가위바위보 & 묵찌빠 게임 프로젝트 
🗓 기간 : 2022.02.14 ~ 2022.02.18(4d)</br>
👨🏻‍💻 팀원 : [쿼카](https://github.com/Quokkaaa), [민성](https://github.com/Minseong-yagom)</br>
✍️ 리뷰어: [제리](https://github.com/llghdud921)</br>


# 순서도
###[STEP1]


###[STEP2]


# 학습 목표
 - Swift의 Optional 안전하게 처리하기
 - if와 switch 조건문의 차이와 장단점 비교해보기
 - 순환함수(재귀함수)와 반복문의 장단점 비교해보기
 - 함수가 한 가지 일만 하도록 기능 분리하기
 - guard 구문의 이해와 활용
 - 동료와 협업자세 고민하기

# 기능 구현
###[타입]
- `private HandGame` : Hand Game의 필요한 기능과 특성들을 담은 값
- `private Kind` : 게임의 종류를 담은 값
- `private Hand` : HandGame에 필요한 패를 담은 값
- `private Player` : 사용자와 컴퓨터를 담은 값
- `private Guide` : 게임 실행시 출력되는 메세지를 담은 값
- `private Result` : 게임결과시 출력 메세지를 담은 값
- `private Erorr` : 잘 못된 입력시 출력되는 메세지를 담은 값

###[프로퍼티]
- `private hasUserWin` : 묵찌빠의 공격자 턴을 구별 해주기 위한 프로퍼티

###[함수]
- `play()` : 가위바위보 및 묵찌빠 게임을 시작
- `private printInputGuidanceMessage()` : 게임에 필요한 입력가이드를 제시
- `private receiveUserInputHand()` : 사용자 패를 입력 받는다
- `private isValueZero()` : 입력된 패가 "0"(게임종료)인지 확인
- `private convertedUserHand()` : 사용자가 입력한 패를 게임에 맞게 변환
- `private generatedRandomHand()` : 컴퓨터의 패 랜덤으로 생성
- `private judgeUserGameResult()` : 가위바위보 결과를 판정
- `private playMukjipa()` : 묵찌빠 게임을 시작
- `private printRockPaperScissorsWinnerTurn()` : 가위바위보 승리자 턴 출력
- `private isWrongInputted` : 정상적인 입력 외에 값인지 검사 
- `private printGameResult()` : 게임결과 메세지를 출력
- `private switchTurn()` : 턴을 변경
- `private printMukjipaWinnerTurn()` : 묵찌빠게임 현재턴을 출력
- `private printMukjipaWinner()` : 묵찌빠게임 승자를 출력
- `private judgeMukjipaWinner()` :  묵찌빠게임 결과를 판정

# 문제 해결 & 어려웠던점 & 고민했던점 & 궁금한점
# [STEP1]
## 문제 해결

- 스위치문으로 `1,2,3,0` 의 사용자 입력 숫자가 있어 스위치문에 제격이라는 판단이 들었다. 그래서 사용자 입력을 그냥 받는 함수와 검증을 하는 함수를 구분하였다. 검증을 하는 함수에서 `123`을 선택시 입력받은 값대로 바로 리턴하게 처리하였고, 디펄트값에는 다시입력하라는 메세지와함께 재귀함수 형태로 진행하였는데 `0`이 굉장히 골치아팠다. 스위치문의 장점은 선택지를 한정하여 그외 값은 디펄트로 처리하는 깔끔한 기능이라고 생각했으나 `return` 처리를 해줘야하는 작업이 들어가서 순수하게 값을 반환하는게 아니라 함수내부에서 `0`에대한 작업을 처리해주거나 미리 0을 처리해주는 함수를 빼서 진행해주어야 했다. 모두다 `return`값을 가져갈 값들이 아니라면 `if`문을 고려해보는 것도 좋으며 반드시 선택지를 제공할 수 있다고해서 `switch`문을 고집하는건 주의하자. 
- `zero`를 넣었더니 `generatedRandomHand`임의의수 생성할때에도 같이 섞여서 오류가 났다. `generatedRandomNumber`생성하는 함수내  `filter`를 이용하여 `0`이 아닌 수들만 저장하는 식으로 처리했다.


## 어려웠던점
- 네비게이터와 드라이버를 30분단위로 체인지하고 함수는 2개, 사용자정의 타입 등 짧지않는 선에서 커밋을 하기로했으나 지켜지지않았다. 암묵적으로 리펙토링을 하면서 서로 코드 교정하고 계속 작성하다보니 그렇게 3,4시간이 흘렀다. 체력적으로도 힘들었고 쉬는시간도 적절히 갖지 못한것같다. TIL을 쓰기 직전에 녹초가되어버렸다. 아무튼 네비게이터와 드라이버를 적절히 분리하여 짝프를해야 안정적이고 규칙적으로 코드를 구현할 수 있는것같다.
- `printGameResult()`에서 비기고 play()로 재귀 `playMukjipa`가 진행되고 결과가 나왔을 때 스택구조로 돌아가면서 `printGameResult()` 끝났을 때 다음 문장인 `playMukjipa`를 바로 실행해버림 이걸 방지하기 위해 플레이 묵찌빠에 조건문을 달아줬다.

## 고민했던점
- 네이밍을 `HandShape`로 할지 Hand로 할지에 대해서 고민을 많이했지만 `Hand`로도 패라는 의미를 표현할 수 있다고 판단되어 수정
- 어려운 난관에 부딪혔을때 해결하기에 앞서 문제를 파악하고 미리 메모해두는것이 시간이 지났을때 잊혀지기때문에 매우 중요하다는 것을 알았다. 내가 어떤 문제에 부딪혔고 그걸 해결하기위해서는 재귀함수 형태로 진행하거나 함수기능을 분리하여 코드 개선을 한 부분을 생각이났을때 즉각적으로 메모하는게 좋음
- `Rock-Paper-Scissors` 타입내 `enum`을 만들어 코드읽기 유연하게 표현하려고 했으나 우려되는점이 코드가 너무 길어질것같다는 점이 있었습니다.

# [STEP2]
## 문제 해결
- 묵찌빠게임에서 `convertedUserHand` 함수로 패를 반환하는데 묵찌빠에서도 재활용이 가능해보였다. 재활용을 하게될시 두가지 문제점이 발생합니다. 첫번째는 패만 반환되는것이아니라 `0` 대한 값도 반환해주어야한다는 점이고 두번째는 가위바위보 게임에서는 사용자입력이 `1`번이 가위이고 `2`번이 바위이지만 묵찌빠에서는 `1`번이 바위이고 `2`번이 가위이다. 

**0에대한 해결방법)** 먼저 사용자입력을 받고나서 바로 `0`인지에대해 검증하는 함수로 연결을 해주는것이다. `0`은 게임을 종료하는 로직이기때문에 가장 먼저 처리해주는것이 적절하기도하다. 그리고 난 후에 `Hand`에 `case end`를 제거해주었다. 이방법은 묵찌빠에서도 적용된다.
**가위바위보게임시 입력 번호와 묵찌빠게임 입력번호 1,2의 차이 해결방법)** gamd Kind라는 열거형을 만들어 가위바위보와 묵찌빠게임에 대한 case를 만들고, `convertedUserHand`함수 매개변수에 `gamekind`타입을 추가해주었다. 그래서 가위바위보게임일때는 `1`번이 가위, 2번이 바위로 처리가되지만 묵찌빠일때는 `if`문으로 `gamekind == .mukjipa`일때는 1,2번을 바꾸어 Hand를 `return`하는 방식을 선택하였다. 그렇게 두줄의 코드를 추가함으로써 `convertedUserHand` 함수를 재사용할 수 있다.

## 어려웠던점
- 묵찌빠게임할때에도 `convertedUserHand`함수를 재활용 할 수 있겠다는 판단이 들었다.묵찌빠게임은 잘 못 입력했을때 사용자입력을 다시 받는 재귀함수 패턴이 아니라 사용자 턴이 바뀌고 입력을 받게된다. `convertedUserHand`함수에서 사용자턴으로 바뀔때 실행될필요없는 `default`값 때문에 초기에는 `if`문을 사용하여 `default`를 빼주는것을 고민해보았으나 잘 못 입력된것에대해서 지속적으로 메세지를 표해주고 재귀함수필요없이 값을 받아주는게 `switch`문의 편리한점때문에 냅두었다. 그런데 재귀가 리턴하는 과정에서 로직에러가 계속발생하고 에러파악하기로 어려워져 불필요한 재귀는 최소화하는 방향으로 `if`문으로 수정하였다. 

## 고민했던점
- `enum Type` `Naming`을 `스위프트 랭귀지 가이드 문서` 를 참고하여 단수로 지정하였다.
- 묵찌빠 게임에서 사용자입력을 받을 함수를 재활용할까고민했는데 재사용성에 대해서 고민해보는것도 좋지만 이를 해결하기위해 만들어지는 함수가 오히려 더 많아지는 역설적인 상황이 생기기도 한다. 이번기회에 재사용성에대해서 고민해보고 삽질을 할 수 있는 좋은기회였던것같다.
- 턴 체인지에 대한 방법고민을 많이했던것같습니다. 그중에서 가장 유연하고 편리한 방법으로  `var hadUserTurn` 프로퍼티를 만들어 턴을 구별해주는 방식으로 처리하였다.
- 재사용성 코드에대해서 고민을 해보았습니다.

# 궁금한점
- 사용자입력받는 함수 실행전에 lldb에 초기화된 값이 찍히는게 궁금합니다. Case첫번째값이 default로 찍히는데 이는 왜그런건가요 ??
- 네이밍문서(https://www.swift.org/documentation/api-design-guidelines/)에 보면 사이드 이펙트가 없는 함수에는 함수명을 명사로 짓는다걸 확인했어요. 저의가 작성한 함수드들은 대부분 사이드이펙드가 없다고 판단되는데 제리에 생각은 어떠한가요?


# 공부한 내용
- Nested Type
중첩타입을 사용할때 struct나 class내에 enum을 사용하게되면 꾀나 유용할 수 있다고 나온다. 추측해보면 예씨문데 struct문 안에 enum이 있는데 클래스가 아닌 이유는 둘다 Value Type이라서 그럴 수 있을까 ? 라는 의문이든다.

중첩타입은 외부에서 인스턴스를 생성할때 변수명을 접두사를 붙여 생성해준다고 랭귀지 가이드에서 확인 해 볼 수 있다.
접두사는 앞에 접미사는 뒤에 덧붙이는 방식인데 예시단어를 봐보자
접두사 - 시퍼렇다, 맨손, 빨간얼굴, 멍든팔
접미사 - 선생님, 쿼카야, 지우개, 먹히다 - 히

- 재귀함수와 반복문의 특징 및 차이점
# 재귀함수와 반복문의 특징
[재귀함수]
- 재귀함수란 함수가 구문내에서 자기자신을 호출하는 것

[장점]
- 원하는 값이 도출할때까지 stack에 메모리가 쌓이기때문에 더 많은 메모리를 사용한다.

[단점]
- 선택적인 구조를 사용한다.
- 형태를 사용하면 코드의 가독성을 높일 수 있다.
- stack관리의 오버헤드로?인해? 반복보다 속도가 느리다.
- 예상치 못한 무한 재귀가 발생할 수 있으며 요즘은 메모리용량이 커 해당사항이 거의 없지만 stack메모리가 많이쌓여 stackOverFlow에 가능성이 나올 수 있다.

[반복문] 
- 반복문이란 조건이 거짓이될때까지 반복적으로 실행되는 것이다.

[장점]
- 반복적인 구조를 가진다.
- stack을 사용하지않으므로 재귀보다 속도가 빠르다.
- 메모리 소모를 덜한다.

[단점]
- 코드가 길어 질 수 있다.
- 조건이 거짓이되지않을시 무한 루프에 빠질 수 있다.
- 루프 조건이 실패하면 반복이 종료된다.

# 재귀함수와 반복문의 차이
- 재귀는 선택적인 구조이지만 반복문은 반복적인 구조이다.
- 재귀함수의 형태는 답정너같은 원리로 원하는 값이 나올떄까지 자신의 함수를 호출하기때문에 추가적인 코드를 구현할 필요가 없지만, 반복문은 특정 값이 나올때까지 반복문을 추가로 구현해줘어야 한다 ?
- 재귀는 stack구조를 메모리를 쌓기때문에 반복보다 더많은 메모리를 사용한다.
- 반복문은 stack구조를 사용하지않아 메모리가 쌓이지않는다. 그래서 속도가 재귀보다 빠르다.
